<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Roxygen2}
-->

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  error = FALSE,
  tidy = FALSE
)
```


# Introduction to roxygen2

Documentation is one of the most important aspects of good code. Without it, users won't know how to use your package, and are unlikely to do so. Documentation is also useful for you in the future (so you remember what the heck you were thinking!), and for other developers working on your package. The goal of roxygen2 is to make documenting your code as easy as possible. Roxygen uses inline comments, so that you code and documentation are co-located, and provides tools to reuse documentation across multiple functions.

R provides a standard way of documenting packages. You create `.Rd` files in the `man/` directory. These files use a custom syntax, based loosely on latex. Roxygen2 provides a number of advantages over writing `.Rd` files by hand:

* Code and documentation are adjacent so when you modify your code, it's easy
  to remember that you need to update the documentation.

* Roxygen2 dynamically inspects the objects that it's documenting, so it
  automatically add data that you'd otherwise have to include by hand.

* It abstracts over the differences in documenting S3 and S4 methods,
  generics and classes so you need to learn fewer details.

This vignette includes the following sections:

* The basic roxygen process

* Common documentation tags

* Documenting S3, S4 and R5 generics, methods and classes.

## Roxygen process

There are three steps in the transformation from roxygen comments in your source file to human readable documentation:

1. You add roxygen comments to your source file.
2. `roxygen2::roxygenise()` converts roxygen comments to `.Rd` files.
3. R converts `.Rd` files to human readable documentation

The process starts when you add specially formatted roxygen comments to your source file. Roxygen comments start with `#'` so you can continue to use regular comments for other purposes.

```{r}
#' Add together two numbers
#'
#' @param x A number
#' @param y A number
#' @return The sum of \code{x} and \code{y}
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  x + y
}
```

Assuming your working directory is set to your package, you can roxygen comments to `.Rd` files with

* `roxygen::roxygenise()`, or
* `devtools::document()`, if you're already using devtools, or
* `Ctrl + Shift + D`,  if you're using RStudio.

For the example, above, this will generate `man/add.Rd` that looks like:

```
% Generated by roxygen2 (3.2.0): do not edit by hand
\name{add}
\alias{add}
\title{Add together two numbers}
\usage{
add(x, y)
}
\arguments{
  \item{x}{A number}

  \item{y}{A number}
}
\value{
The sum of \code{x} and \code{y}
}
\description{
Add together two numbers
}
\examples{
add(1, 1)
add(10, 1)
}
```

Rd files are a special file format loosely based on LaTeX. You can read more about the Rd format in the [R extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Rd-format) manual. Here we'll avoid discussing Rd files as much as possible, focussing instead on what you need to know about roxygen2.

When you use `?x`, `help("x")` or `example("x")` R looks for an Rd file containing `\alias{x}`. It then parses the file, converts it into html and displays it.

All of these functions look for an Rd file in _installed_ packages. This isn't very useful for package development, because you want to use the `.Rd` files in the _source_ package. `devtools` provides two helpful functions for this scenario: `dev_help()` and `dev_example()`. They behave similarly to `help()` and `example()` but look in source packages you've loaded with `load_all()`, not installed packages you've loaded with `library()`.

## Basic documentation

As you've seen,  roxygen comments have a special format. They start with `#'` and include tags that like `@tagname`. Tags break the documentation up into pieces, and the content of a tag extends from the end of tag name to the start of the next tag (or the end of the block). Because `@` has a special meaning in roxygen, you need to write `@@` to add a literal `@` to the documentation.

Each documentation block starts with a text description. The first sentence becomes the title of the documentation. That's what you see when you look at `help(package = mypackage)` and is shown at the top of the documentation for each package. It should be succinct, written in sentence case, and end in a full stop. The second paragraph is the description: this is shown first in the documentation and should briefly describe what the function does. The third and subsequent paragraphs go into the details: this is a (often long) section that comes after the description of the parameters. It should provide any other important details of how the function operates.

Here's an example showing what the documentation for `sum` might look like if it was written using roxygen:

```{r}
#' Sum of vector elements.
#'
#' \code{sum} returns the sum of all the values present in its arguments.
#'
#' This is a generic function: methods can be defined for it directly
#' or via the \code{\link{Summary}} group generic. For this to work properly,
#' the arguments \code{...} should be unnamed, and dispatch is on the
#' first argument.
sum <- function(..., na.rm = TRUE) {}
```

(You'll learn what `\code{}` and `\link{}` mean a little later)

The following documentation is equivalent, but uses explicit tags.  This is not necessary unless you want to have a multiple paragraph description or title, or want to omit the description (in which case roxygen will use the title for the description, since it's a required component of the `.Rd` file).

```{r}
#' @title Sum of Vector Elements
#'
#' @description
#' \code{sum} returns the sum of all the values present in its arguments.
#'
#' @details
#' This is a generic function: methods can be defined for it directly
#' or via the \code{\link{Summary}} group generic. For this to work properly,
#' the arguments \code{...} should be unnamed, and dispatch is on the
#' first argument.
sum <- function(..., na.rm = TRUE) {}
```

The following sections describe the other most useful roxygen tags as they pertain to the different types of object you might want to document.

## Documenting functions

The following code shows the arrange function and its documentation from the
plyr package.

```{r}
#' Order a data frame by its columns.
#'
#' This function completes the subsetting, transforming and ordering triad
#' with a function that works in a similar way to \code{\link{subset}} and
#' \code{\link{transform}} but for reordering a data frame by its columns.
#' This saves a lot of typing!
#'
#' @param df data frame to reorder
#' @param ... expressions evaluated in the context of \code{df} and
#'   then fed to \code{\link{order}}
#' @keywords manip
#' @export
#' @examples
#' mtcars[with(mtcars, order(cyl, disp)), ]
#' arrange(mtcars, cyl, disp)
#' arrange(mtcars, cyl, desc(disp))
arrange <- function(df, ...) {
  ord <- eval(substitute(order(...)), df, parent.frame())
  unrowname(df[ord, ])
}
```

The tags used here are:

* `@param arg description` - a description for each function argument. This
  can span multiple lines (or even paragraphs) if necessary.

* `@examples` - examples of the function in use. In my opinion, this is the
  most important part of the documentation - these are what most people will
  look at first to figure out how to use the function. I always put this last.

Other tags that you might find useful are:

* `@return` - the type of object that the function returns

The following tags apply to all types of documentation

* `@author`, in the form `Firstname Lastname <email@@address.com>`. Use this if
  some of the functions are written by people other than the author of the
  package.

* `@seealso` - to provide pointers to other related topics

* `@references` - references to scientific literature on this topic

* `@aliases` - a list of additional topic names that will be mapped to this
  documentation when the user looks them up from the command line.

* `@family` - a family name. All functions that have the same family tag will be linked
  in the documentation.

## Documenting methods and generics

### S3

S3 generics are documented in the same way as functions - there is typically no reason for a user to know (or care) that a function is a generic. (Although you may want to mention it in the docs so that other developers know that they can extend it with their own methods).

If you `@export` an S3 generic function, all its methods defined in your package will also get exported appropriately (using the `S3method()` namespace directive): they will be available when you call the generic, but users can not call the methods directly.  For example, the `wday` generic in `lubridate` is exported:

```{r, eval = FALSE}
library(lubridate)
wday(Sys.Date(), label = TRUE)
wday(1, label = TRUE)
```

But you can't call any of the methods directly:

```{r, eval = FALSE}
wday.default(Sys.Date(), label = TRUE)
wday.numeric(1, label = TRUE)

lubridate:::wday.default(Sys.Date(), label = TRUE)
lubridate:::wday.numeric(1, label = TRUE)
```

This is good practice because it hides the internal implementation details of your functions.  Users should not rely on specific behaviour (for example, in this case we need to call `wday.default` for Date objects).  This makes it easier for you to change how the functions work in the future - for example, you could change from S3 to S4 dispatch.

You only need to explicitly `@export` a method if it's for a generic defined in another package.  This is one of the easiest things to forget, and it creates subtle bugs that `R CMD check` doesn't report and are hard to track down.  Future versions of roxygen should hopefully make this easier.

Most of the time you don't need to document S3 methods - particularly if they are for simple generics like `print`.  However, if your method is more complicated, you should document it.  In base R, you can find documentation for more complex methods like `predict.lm`, `predict.glm`, `anova.glm` and so on.

### S4

The same rules apply when documenting S4 generics and methods:

* Document the generic like you would document any function.  Document
  methods that are more complex or have significant differences in behaviours.

* You don't need to export methods if they're for a generic you defined
  (just export the generic). Export all methods for generics defined in
  other packages.

## R5 methods

Document R5 methods with the standard docstring format.

## Documenting classes

### S3

Since S3 classes have no formal structure, you should document the constructor function.

### S4

Typically you should document the `setClass` call, and if present, the constructor function.  Unless you want to separate out internal documentation for the class and the public interface (for the constructor), I recommend using `@rdname` to document both in the same file.  This will mean that `?classname` and `class?classname` go to the same place.

Export the class if you want other developers to be able to write subclasses of your class.  Export the constructor if you want users to be able to use it.

### R5

## Documenting datasets

The following documentation excerpt comes from the diamonds dataset in ggplot2. We can't document the object directly (because it lives in the data directory), so we document `NULL` and provide the `@name` of the object we really want to document.

```{r}
#' Prices of 50,000 round cut diamonds.
#'
#' A dataset containing the prices and other attributes of almost 54,000
#'  diamonds. The variables are as follows:
#'
#' \itemize{
#'   \item price. price in US dollars (\$326--\$18,823)
#'   \item carat. weight of the diamond (0.2--5.01)
#'   ...
#' }
#'
#' @keywords datasets
#' @format A data frame with 53940 rows and 10 variables
#' @name diamonds
NULL
```

There are a few new tags:

* `@docType data`, which indicates that this is documentation for a dataset.

* `@format`, which gives an overview of the structure of the dataset. If you omit this, roxygen will automatically add something based on the first line of `str` output

* `@source` where you got the data form, often a `\url{}`.

## Documenting packages

Every package should also have its own documentation page. I usually put this documentation in a file with the same name as the package.

This documentation topic should contain an overview documentation topic that describes the overall purpose of the package, and points to the most important functions. This topic should have `@docType package` and be aliased to `package-pkgname` and `pkgname` (unless there is already a function by that name) so that you can get an overview of the package by doing `?pkgname` or `package?pkgname`.

There are still relatively few packages that provide package documentation, but it's an extremely useful tool for users, because instead of just listing functions like `help(package = pkgname)` it organises them and shows the user where to get started.

The example below shows the basic structure, as taken from the documentation for the `lubridate` package:

```{r}
#' Dates and times made easy with lubridate.
#'
#' Lubridate provides tools that make it easier to parse and
#' manipulate dates. These tools are grouped below by common
#' purpose. More information about each function can be found in
#' its help documentation.
#'
#' Parsing dates
#'
#' Lubridate's parsing functions read strings into R as POSIXct
#' date-time objects. Users should choose the function whose name
#' models the order in which the year ('y'), month ('m') and day
#' ('d') elements appear the string to be parsed:
#' \code{\link{dmy}}, \code{\link{myd}}, \code{\link{ymd}},
#' \code{\link{ydm}}, \code{\link{dym}}, \code{\link{mdy}},
#' \code{\link{ymd_hms}}).
#'
#' ...
#'
#' @references Garrett Grolemund, Hadley Wickham (2011). Dates and Times
#'   Made Easy with lubridate. Journal of Statistical Software, 40(3),
#'   1-25. \url{http://www.jstatsoft.org/v40/i03/}.
#' @import plyr stringr
#' @docType package
#' @name lubridate
NULL
```

Important components are:

* The general overview of the package: what it does, and what are the
  important pieces.

* Like for data sets, there isn't a object that we can document directly so
  document `NULL` and use `@name` to say what we're actually documenting

* `@docType package` to indicate that it's documenting a package. This will
  automatically add the corect aliases so that `package?yourpackage` works.

* `@references` point to any published material about the package that users
  might find help.

The package documentation should not contain a verbatim list of functions or copy of `DESCRIPTION`. This file is for human reading, so pick the most important elements of your package.

## Text formatting

Within roxygen text, you use the usual R documentation formatting rules, as summarised below. A fuller description is available in the [R extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Sectioning) manual.

Sections are indicated by the @section tag, followed by the title (which should be in sentence case) and a colon.

Subsections are indicated by a LaTeX-style command; the first argument is the subsection title and the second argument contains the subsection content. The following example illustrates how to add an arbitrary section:

```{r}
#' @section Warning:
#' You must not call this function unless ...
#'
#' \subsection{Exceptions}{
#'    Apart from the following special cases...
#' }
```

The section ends when another tag is declared or when the roxygen2 block ends.

### Lists

* Ordered (numbered) lists:

    ```{r}
    #' \enumerate{
    #'   \item First item
    #' \item Second item
    #' }
    ```

* Unordered (bulleted) lists

    ```{r}
    #' \itemize{
    #'  \item First item
    #'  \item Second item
    #' }
    ```

* Definition (named) lists

    ```{r}
    #' \describe{
    #'  \item{One}{First item}
    #'  \item{Two}{Second item}
    #' }
    ```

### Tables

Tables are created with the tabular command, which has two arguments:

* Column alignment: a letter for each column. `l` = left alignment, `c` = centre, `r` = right.

* Table contents.  Columns separated by `\tab`, rows separated by `\cr`.

The following function will turn an R data frame into the correct format.  It ignores column and row names, but should get you started.

```{r}
tabular <- function(df) {
  stopifnot(is.data.frame(df))
  align <- function(x) if (is.numeric(x)) "r" else "l"
  col_align <- vapply(df, align, character(1))

  contents <- do.call("paste", c(lapply(df, format),
    list(sep = " \\tab ", collapse = "\\cr\n")))

  mat <- matrix(unlist(lapply(df, format)), ncol = ncol(df))
  paste("\\tabular{", paste(col_align, collapse = ""), "}{\n",
    contents, "}\n", sep = "")
}
```

### Mathematics

`\eqn` for inline, `\deqn` for display.  Standard LaTeX (no extensions).

### Character formatting

* `\emph{text}`: emphasised text, usually displayed as _italics_

* `\strong{text}`: strong text, usually displayed in __bold__

* `\code{text}`, `\pkg{package_name}`, `\file{file_name}`

* External links: `\email{email_address}`, `\url{url}`, `\href{url}{text}`

* `\link[package]{function}` - the first argument can be omitted if the link
  is in the current package, or the base package.  Will usually be wrapped inside `\code`: `\code{\link{fun}}`
