---
title: "Extending roxygen2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Extending roxygen2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(comment = "#>", collapse = TRUE)
```

## Basics

Roxygen is extensible with user-defined __roclets__. 
It means that you can take advantage of Roxygen's parser and extend it with your own `@tags`.

Note that's not currently possible to extend an existing roclet, so you need to create your own if you want to add new features. This restriction may be relaxed in the future.

```{r setup}
library(roxygen2)
```

## Key data structures

Before we talk about creating your own roclets, we need to first discuss two important data structures that power roxygen: blocks and tags.

### Tags

A tag (a list with S3 class `roxy_tag`) represents a single tag. 
It contains:

* `tag`: the name of the tag.

* `raw`: the raw contents of the tag (i.e. everything from the end of 
  this tag to the begining of the net).
  
* `val`: the parsed value, which we'll come back to shortly.

* `file` and `line`: the location of the tag in the package. Used
  with `roxy_tag_warning()` to produce informative error messages.

You _can_ construct tag objects by hand with `roxy_tag()`:

```{r}
roxy_tag("name", "Hadley")
str(roxy_tag("name", "Hadley"))
```

However, you should rarely need to do so, because you'll typically have them given to you in a block object

## Blocks

A block (a list with S3 class `roxy_block`) represents a single roxygen block. It contains:

* `tags`: a list of `roxy_tags`.
* `call`: the R code associated with the block (usually a function call).
* `file` and `line`: the location of the R code.
* `object`: the evaluated R object associated with the code.

The easiest way to see the basic structure of a `roxy_block()` is to generate one by parsing a roxygen block:

```{r}
text <- "
  #' This is a title
  #'
  #' @param x,y A number
  #' @export
  f <- function(x, y) x + y
"

# parse_text() returns a list of blocks, so I extract the first
block <- parse_text(text)[[1]]
block
```

## Roclets

Creating a new roclet is usually a two part process.
First, you define new tags that your roclet will work with.
Second, you define a roclet that tells roxygen how to process an entire package.

### Custom tags

In this example we will make a new `@memo` tag to enable printing the memos at the console when the roclet runs.
We choose that the `@memo` has this syntax:

```
@memo [Headline] Description
```

As an example:

```
@memo [EFFICIENCY] Currently brute-force; find better algorithm.
```

To make our roclet work, we first define a method for `roxy_tag_parse`. 
The name of the class will be `roxy_tag_{tag}`, which in this case is `roxy_tag_memo`.
This function takes a `roxy_tag` as input, and it's job is to set `x$val` to a convenient parsed value that will be used later by the roclet.

```{r}
roxy_tag_parse.roxy_tag_memo <- function(x) {
  if (!grepl("^\\[.*\\].*$", x$raw)) {
    roxy_tag_warning(x, "Invalid memo format")
    return()
  }

  parsed <- stringi::stri_match(str = x$raw, regex = "\\[(.*)\\](.*)")[1, ]

  x$val <- list(
    header = parsed[[2]], 
    message = parsed[[3]]
  )
  x
}
```

```{r, include = FALSE}
# Needed for vignette
registerS3method("roxy_tag_parse", "roxy_tag_memo", roxy_tag_parse.roxy_tag_memo)
```

We check this works by using `parse_text()`:

```{r}
text <- "
  #' @memo [TBI] Remember to implement this!
  #' @memo [API] Check best API
  f <- function(x, y) {
    # ...
  }
"
block <- parse_text(text)[[1]]
block

str(block$tags[[1]])
```

## The roclet

To create a roclet, you first create a roclet object using `roclet()`.
Our `memo` roclet doesn't have any options so this is very simple here:

```{r}
memo_roclet <- function() {
  roclet("memo")
}
```

To give the roclet behaviour, you need to define method.
There are two methods that almost every roclet will use:

* `roclet_process()` is called with a list of blocks, and returns an
  object of your choosing.
  
* `roclet_output()`: performs side-effects (usually writing to disk)
  using the result from `roclet_process()`

For this roclet, we'll have `roclet_process()` collect all the memo tags into a named list:

```{r}
roclet_process.roclet_memo <- function(x, blocks, env, base_path, global_options = list()) {
  results <- list()
  
  for (block in blocks) {
    tags <- block_get_tags(block, "memo")

    for (tag in tags) {
      msg <- paste0("[", tag$file, ":", tag$line, "] ", tag$val$message)
      results[[tag$val$header]] <- c(results[[tag$val$header]], msg)
    }
  }
  
  results
}
```

And then have `roclet_output()` just print them to the screen:

```{r}
roclet_output.roclet_memo <- function(x, results, base_path, ...) {
  for (header in names(results)) {
    messages <- results[[header]]
    cat(paste0(header, ": ", "\n"))
    cat(paste0(" * ", messages, "\n", collapse = ""))
  }

  invisible(NULL)
}
```

```{r, include = FALSE}
# Needed for vignette
registerS3method("roclet_process", "roclet_memo", roclet_process.roclet_memo)
registerS3method("roclet_output", "roclet_memo", roclet_output.roclet_memo)
```

Then you can test it works by using `roc_proc_text()`:

```{r}
results <- roc_proc_text(memo_roclet(), "
#' @memo [TBI] Remember to implement this!
#' @memo [API] Check best API
f <- function(x, y) {
  # ...
}

#' @memo [API] Consider passing z option
g <- function(x, y) {
  # ...
}
")
roclet_output(memo_roclet(), results)
```

